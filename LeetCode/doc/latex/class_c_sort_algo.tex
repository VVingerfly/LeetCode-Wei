\hypertarget{class_c_sort_algo}{}\section{C\+Sort\+Algo Class Reference}
\label{class_c_sort_algo}\index{C\+Sort\+Algo@{C\+Sort\+Algo}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_c_sort_algo_a2eb6522682aab00c1df2eb3798912c97}{}\label{class_c_sort_algo_a2eb6522682aab00c1df2eb3798912c97} 
void \hyperlink{class_c_sort_algo_a2eb6522682aab00c1df2eb3798912c97}{test\+\_\+sort} ()
\begin{DoxyCompactList}\small\item\em 排序算法测试函数 \end{DoxyCompactList}\item 
void \hyperlink{class_c_sort_algo_a73fd2ee73bc017fdd76eb8bdab10c02d}{print\+\_\+nums} (const vector$<$ int $>$ \&nums)
\begin{DoxyCompactList}\small\item\em print all the elements of a array \end{DoxyCompactList}\item 
void \hyperlink{class_c_sort_algo_a3e16fa837f31b55a907c2ae08010441c}{randon\+\_\+nums} (int len)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_c_sort_algo_a0ce54b0167d658aedf0f603979761c88}{bubble\+\_\+sort} (vector$<$ int $>$ \&nums)
\begin{DoxyCompactList}\small\item\em 冒泡排序 \end{DoxyCompactList}\item 
void \hyperlink{class_c_sort_algo_aeef7ae8fed73aa9997f4e2443fcfdf4b}{select\+\_\+sort} (vector$<$ int $>$ \&nums)
\begin{DoxyCompactList}\small\item\em 选择排序 \end{DoxyCompactList}\item 
void \hyperlink{class_c_sort_algo_a3095752baa5f6d51934e89baf62d7361}{insert\+\_\+sort} (vector$<$ int $>$ \&nums)
\begin{DoxyCompactList}\small\item\em 插入排序 \end{DoxyCompactList}\item 
void \hyperlink{class_c_sort_algo_ad37a6f012070a0a39dcdb5d6beed4c93}{quick\+\_\+sort} (vector$<$ int $>$ \&nums, int left, int right)
\begin{DoxyCompactList}\small\item\em 快速排序 \end{DoxyCompactList}\item 
void \hyperlink{class_c_sort_algo_a25109772bb378cf42f34813e06d8a9d1}{merge\+\_\+sort} (vector$<$ int $>$ \&nums, vector$<$ int $>$ \&nums\+\_\+temp, int start\+\_\+index, int end\+\_\+index)
\begin{DoxyCompactList}\small\item\em 快速排序 \end{DoxyCompactList}\item 
\hypertarget{class_c_sort_algo_a148af9c8ca6ff69d7eead2464dbbffe5}{}\label{class_c_sort_algo_a148af9c8ca6ff69d7eead2464dbbffe5} 
void {\bfseries merge} (vector$<$ int $>$ \&nums, vector$<$ int $>$ \&nums\+\_\+temp, int start\+\_\+index, int mid\+\_\+index, int end\+\_\+index)
\item 
void \hyperlink{class_c_sort_algo_ad81a03f9e4a3d1d0a3690485c35acd44}{heap\+\_\+sort} (vector$<$ int $>$ \&nums)
\begin{DoxyCompactList}\small\item\em 堆排序 \end{DoxyCompactList}\item 
\hypertarget{class_c_sort_algo_a4e914cae14c15e8a75c7cea33ed9b439}{}\label{class_c_sort_algo_a4e914cae14c15e8a75c7cea33ed9b439} 
void {\bfseries heap\+\_\+adjust} (vector$<$ int $>$ \&nums, int i, int len)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_c_sort_algo_ae796c28480b9ea83543635bd13fd14fc}{}\label{class_c_sort_algo_ae796c28480b9ea83543635bd13fd14fc} 
vector$<$ int $>$ {\bfseries nums\+\_\+}
\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\hypertarget{class_c_sort_algo_a0ce54b0167d658aedf0f603979761c88}{}\label{class_c_sort_algo_a0ce54b0167d658aedf0f603979761c88} 
\index{C\+Sort\+Algo@{C\+Sort\+Algo}!bubble\+\_\+sort@{bubble\+\_\+sort}}
\index{bubble\+\_\+sort@{bubble\+\_\+sort}!C\+Sort\+Algo@{C\+Sort\+Algo}}
\subsubsection{\texorpdfstring{bubble\+\_\+sort()}{bubble\_sort()}}
{\footnotesize\ttfamily void C\+Sort\+Algo\+::bubble\+\_\+sort (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{nums }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



冒泡排序 

算法之原理： 相邻的数据进行两两比较，小数放在前面，大数放在后面, 这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成。 ~\newline
时间复杂度： 平均 O(n$^\wedge$2) 最坏 O(n$^\wedge$2) ~\newline
空间复杂度： O(1) ~\newline
算法稳定性： 稳定 ~\newline

\begin{DoxyParams}{Parameters}
{\em nums} & the array to sort \\
\hline
\end{DoxyParams}
\hypertarget{class_c_sort_algo_ad81a03f9e4a3d1d0a3690485c35acd44}{}\label{class_c_sort_algo_ad81a03f9e4a3d1d0a3690485c35acd44} 
\index{C\+Sort\+Algo@{C\+Sort\+Algo}!heap\+\_\+sort@{heap\+\_\+sort}}
\index{heap\+\_\+sort@{heap\+\_\+sort}!C\+Sort\+Algo@{C\+Sort\+Algo}}
\subsubsection{\texorpdfstring{heap\+\_\+sort()}{heap\_sort()}}
{\footnotesize\ttfamily void C\+Sort\+Algo\+::heap\+\_\+sort (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{nums }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



堆排序 

算法之原理： （以最大堆为例）
\begin{DoxyEnumerate}
\item 先将初始数据R\mbox{[}1..n\mbox{]}建成一个最大堆，此堆为初始的无序区
\item 再将关键字最大的记录R\mbox{[}1\mbox{]}（即堆顶）和无序区的最后一个记录R\mbox{[}n\mbox{]}交换， 由此得到新的无序区R\mbox{[}1..n -\/ 1\mbox{]}和有序区R\mbox{[}n\mbox{]}，且满足R\mbox{[}1..n -\/ 1\mbox{]}.keys≤R\mbox{[}n\mbox{]}.key
\item 由于交换后新的根R\mbox{[}1\mbox{]}可能违反堆性质，故应将当前无序区R\mbox{[}1..n -\/ 1\mbox{]}调整为堆。 重复2、3步骤，直到无序区只有一个元素为止。~\newline
时间复杂度： 平均 O(nlogn) 最坏 O(nlogn) ~\newline
空间复杂度： O(1) ~\newline
算法稳定性： 不稳定 ~\newline

\begin{DoxyParams}{Parameters}
{\em nums} & the array to sort \\
\hline
\end{DoxyParams}

\end{DoxyEnumerate}\hypertarget{class_c_sort_algo_a3095752baa5f6d51934e89baf62d7361}{}\label{class_c_sort_algo_a3095752baa5f6d51934e89baf62d7361} 
\index{C\+Sort\+Algo@{C\+Sort\+Algo}!insert\+\_\+sort@{insert\+\_\+sort}}
\index{insert\+\_\+sort@{insert\+\_\+sort}!C\+Sort\+Algo@{C\+Sort\+Algo}}
\subsubsection{\texorpdfstring{insert\+\_\+sort()}{insert\_sort()}}
{\footnotesize\ttfamily void C\+Sort\+Algo\+::insert\+\_\+sort (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{nums }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



插入排序 

算法之原理： 将数据分为两部分，有序部分与无序部分，一开始有序部分包含第1个元素， 依次将无序的元素插入到有序部分，直到所有元素有序。 插入排序又分为直接插入排序、二分插入排序、链表插入等，这里只讨论直接插入排序。~\newline
时间复杂度： 平均 O(n$^\wedge$2) 最坏 O(n$^\wedge$2) ~\newline
空间复杂度： O(1) ~\newline
算法稳定性： 稳定 ~\newline

\begin{DoxyParams}{Parameters}
{\em nums} & the array to sort \\
\hline
\end{DoxyParams}
\hypertarget{class_c_sort_algo_a25109772bb378cf42f34813e06d8a9d1}{}\label{class_c_sort_algo_a25109772bb378cf42f34813e06d8a9d1} 
\index{C\+Sort\+Algo@{C\+Sort\+Algo}!merge\+\_\+sort@{merge\+\_\+sort}}
\index{merge\+\_\+sort@{merge\+\_\+sort}!C\+Sort\+Algo@{C\+Sort\+Algo}}
\subsubsection{\texorpdfstring{merge\+\_\+sort()}{merge\_sort()}}
{\footnotesize\ttfamily void C\+Sort\+Algo\+::merge\+\_\+sort (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{nums,  }\item[{vector$<$ int $>$ \&}]{nums\+\_\+temp,  }\item[{int}]{start\+\_\+index,  }\item[{int}]{end\+\_\+index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



快速排序 

算法之原理： 归并排序具体工作原理如下（假设序列共有n个元素）： 将序列每相邻两个数字进行归并操作（merge)，形成floor(n / 2)个序列，排序后每个序列包含两个元素 将上述序列再次归并，形成floor(n / 4)个序列，每个序列包含四个元素 重复步骤2，直到所有元素排序完毕。~\newline
时间复杂度： 平均 O(nlogn) 最坏 O(nlogn) ~\newline
空间复杂度： O(1) ~\newline
算法稳定性： 稳定 ~\newline

\begin{DoxyParams}{Parameters}
{\em nums} & the array to sort \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
如果是使用链表的实现的话，空间复杂度可以达到\+O(1)， 但如果是使用数组来存储数据的话，在归并的过程中，需要临时空间来存储归并好的数据，所以空间复杂度为\+O(n) 
\end{DoxyNote}
\hypertarget{class_c_sort_algo_a73fd2ee73bc017fdd76eb8bdab10c02d}{}\label{class_c_sort_algo_a73fd2ee73bc017fdd76eb8bdab10c02d} 
\index{C\+Sort\+Algo@{C\+Sort\+Algo}!print\+\_\+nums@{print\+\_\+nums}}
\index{print\+\_\+nums@{print\+\_\+nums}!C\+Sort\+Algo@{C\+Sort\+Algo}}
\subsubsection{\texorpdfstring{print\+\_\+nums()}{print\_nums()}}
{\footnotesize\ttfamily void C\+Sort\+Algo\+::print\+\_\+nums (\begin{DoxyParamCaption}\item[{const vector$<$ int $>$ \&}]{nums }\end{DoxyParamCaption})}



print all the elements of a array 


\begin{DoxyParams}{Parameters}
{\em nums} & the array to print \\
\hline
\end{DoxyParams}
\hypertarget{class_c_sort_algo_ad37a6f012070a0a39dcdb5d6beed4c93}{}\label{class_c_sort_algo_ad37a6f012070a0a39dcdb5d6beed4c93} 
\index{C\+Sort\+Algo@{C\+Sort\+Algo}!quick\+\_\+sort@{quick\+\_\+sort}}
\index{quick\+\_\+sort@{quick\+\_\+sort}!C\+Sort\+Algo@{C\+Sort\+Algo}}
\subsubsection{\texorpdfstring{quick\+\_\+sort()}{quick\_sort()}}
{\footnotesize\ttfamily void C\+Sort\+Algo\+::quick\+\_\+sort (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{nums,  }\item[{int}]{left,  }\item[{int}]{right }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



快速排序 

算法之原理： 快速排序是目前在实践中非常高效的一种排序算法。 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小， 然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。~\newline
时间复杂度： 平均 O(nlogn) 最坏 O(n$^\wedge$2) ~\newline
空间复杂度： O(logn) ~\newline
算法稳定性： 不稳定 ~\newline

\begin{DoxyParams}{Parameters}
{\em nums} & the array to sort \\
\hline
{\em left} & \\
\hline
{\em right} & \\
\hline
\end{DoxyParams}
\hypertarget{class_c_sort_algo_a3e16fa837f31b55a907c2ae08010441c}{}\label{class_c_sort_algo_a3e16fa837f31b55a907c2ae08010441c} 
\index{C\+Sort\+Algo@{C\+Sort\+Algo}!randon\+\_\+nums@{randon\+\_\+nums}}
\index{randon\+\_\+nums@{randon\+\_\+nums}!C\+Sort\+Algo@{C\+Sort\+Algo}}
\subsubsection{\texorpdfstring{randon\+\_\+nums()}{randon\_nums()}}
{\footnotesize\ttfamily void C\+Sort\+Algo\+::randon\+\_\+nums (\begin{DoxyParamCaption}\item[{int}]{len }\end{DoxyParamCaption})}

generate a int array with size len 
\begin{DoxyParams}{Parameters}
{\em len} & the length of the array \\
\hline
\end{DoxyParams}
\hypertarget{class_c_sort_algo_aeef7ae8fed73aa9997f4e2443fcfdf4b}{}\label{class_c_sort_algo_aeef7ae8fed73aa9997f4e2443fcfdf4b} 
\index{C\+Sort\+Algo@{C\+Sort\+Algo}!select\+\_\+sort@{select\+\_\+sort}}
\index{select\+\_\+sort@{select\+\_\+sort}!C\+Sort\+Algo@{C\+Sort\+Algo}}
\subsubsection{\texorpdfstring{select\+\_\+sort()}{select\_sort()}}
{\footnotesize\ttfamily void C\+Sort\+Algo\+::select\+\_\+sort (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{nums }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



选择排序 

算法之原理： 先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置， 然后，再从剩余未排序元素中继续寻找最小（大）元素， 然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。~\newline
时间复杂度： 平均 O(n$^\wedge$2) 最坏 O(n$^\wedge$2) ~\newline
空间复杂度： O(1) ~\newline
算法稳定性： 不稳定 ~\newline

\begin{DoxyParams}{Parameters}
{\em nums} & the array to sort \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
F\+:/\+U\+S\+T\+C\+Study/\+C\+Plus\+Plus/\+Leet\+Code-\/\+Wei/\+Leet\+Code/src/\+Sort/sort\+\_\+algo.\+h\item 
F\+:/\+U\+S\+T\+C\+Study/\+C\+Plus\+Plus/\+Leet\+Code-\/\+Wei/\+Leet\+Code/src/\+Sort/sort\+\_\+algo.\+cpp\end{DoxyCompactItemize}
